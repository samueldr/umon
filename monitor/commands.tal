( ---------------------------------------------- )
( Monitor program - Monitor commands             )
( ---------------------------------------------- )
( NOTE: all labels and macros **HAVE** to start  )
(       with `monitor:`.                         )
( ---------------------------------------------- )
( This file implements the commands.             )
( ---------------------------------------------- )

@monitor:command:flush ( cmd -- )
	( Load the current the command )
	;monitor:variables/cmd LDA
	DUP .monitor:Command/quit      NEQ ?{ POP2r POP2 ;monitor:stop JMP2 }
	DUP .monitor:Command/debug     NEQ ?{ monitor:bios:debug }
	DUP .monitor:Command/show      NEQ ?{ monitor:command:show }
	DUP .monitor:Command/write     NEQ ?{ monitor:command:write }
	DUP .monitor:Command/go        NEQ ?{ monitor:command:go }
	DUP .monitor:Command/pop       NEQ ?{ POP !monitor:command:pop }
	DUP .monitor:Command/push      NEQ ?{ POP !monitor:command:push }

	( Drop the command loaded previously )
	POP

	( Skip to here when manipulating stack )
	&stack-done

	monitor:reset-state
	JMP2r

@monitor:command:show
	( Load the current address on WST )
	;monitor:variables/current LDA2

	( Print format )
	DUP2 monitor:print-short ( Print the current address )
	LIT ": monitor:bios:putc      ( : )
	LIT 20 monitor:bios:putc      ( Space )
	LDA monitor:print-byte   ( value )
	monitor:print-nl
	JMP2r

@monitor:command:write
	( Load the to-be-written byte on WST )
	[ ;monitor:variables/value LDA ]    ( -- value )
	( Load the current address on WST )
	[ ;monitor:variables/current LDA2 ] ( -- value addr* )
	( Write it! )
	STA
	JMP2r

@monitor:command:pop ( [byte] char -- char ) ( OR ) ( [`byte] `ret* -- `ret* )
	monitor:command:on_rst? ?{
		ROTr
		POPr
		!monitor:command:flush/stack-done
	}
	( else ) [
		SWP ( [byte] char -- char [byte] )
		POP ( char [byte] -- char )
		!monitor:command:flush/stack-done
	]

@monitor:command:push ( char -- [byte] char ) ( OR ) ( `ret* -- [`byte] `ret* )
	[ ;monitor:variables/value LDA ] ( char value -- )
	monitor:command:on_rst? ?{
		STH     ( value `ret* -- `ret* `value )
		ROTr ROTr ( `ret* `value -- `value `ret* )
		!monitor:command:flush/stack-done
	}
	( else ) [
		SWP ( char value -- value char )
		!monitor:command:flush/stack-done
	]

@monitor:command:on_rst? ( -- RST? )
	;monitor:variables/parser_state LDA
	.monitor:ParserState/stack_wst  AND
	JMP2r

@monitor:command:go
	( Load the current address on WST )
	;monitor:variables/current LDA2
	( Go, hoping we get back here... )
	( JSR2 JMP2r )
	( Save one instruction by assuming the routine will JMP2r anyway. )
	JMP2
