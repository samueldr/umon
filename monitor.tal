( ---------------------------------------------- )
( Monitor program                                )
( ---------------------------------------------- )
( NOTE: all labels and macros **HAVE** to start  )
(       with `monitor:`.                         )
( ---------------------------------------------- )
( NOTE: Assumes well-known varvara labels are    )
(       in scope.                                )
( ---------------------------------------------- )

( Console read/write )
%monitor:getc  { .Console/read DEI  }
%monitor:putc  { .Console/write DEO }
%monitor:debug { #ab .System/debug DEO }

( Bits manipulation )
%monitor:nibble:high { #04 SFT }
%monitor:nibble:low  { #0f AND }

( Start of the memory area for the monitor )
@monitor

( Scratch area reserved for runtime manipulations )
@monitor:variables
	&PC       $2 ( previous PC )
	&con-vec  $2 ( previous console vector )
	( Used by the monitor )
	&current  $2   ( Current address )
	( Used by the parser )
	&cmd      00 ( Current command )

( Starts the monitor program, replacing the console vector. )
@monitor:start
	STH2r DUP2 ;monitor:variables/PC STA2 ( Store the current PC, to jump back to it when done. )
	LIT "@ monitor:putc
	monitor:print-short
	monitor:print-nl
	( Save the console vector )
	[ .Console/vector DEI2 ] ;monitor:variables/con-vec STA2
	;monitor:on-console .Console/vector DEO2

	( Reset state )
	.monitor:Command/none    ;monitor:variables/cmd STA
	;monitor:parser:commands ;monitor:on-console/current-parser STA2

	monitor:prompt
	BRK

( Stops the monitor program, putting back the console vector. )
@monitor:stop
	( Restore console vector )
	;monitor:variables/con-vec LDA2
	.Console/vector DEO2

	( Fish back PC from when we started )
	;monitor:variables/PC LDA2
	STH2
	JMP2r

( Prints the prompt for the monitor )
@monitor:prompt
	monitor:print-nl
	LIT "$ monitor:putc
	;monitor:variables/current LDA2
	monitor:print-short
	;/ps1 puts
	JMP2r
	&ps1 "> 20 00

( Handles monitor input )
@monitor:on-console ( -- )
	monitor:getc

	( Handling in-flight commands )
	DUP LIT 0a NEQ ?{ monitor:command:flush monitor:prompt !/done }
	DUP LIT SP NEQ ?{ monitor:command:flush                !/done }
	
	( Go to the current parser from LUT )
	LIT2 &current-parser 0000
		JMP2 ( NOTE: parsers should BRK as needed )

	&done
	POP ( Drop current char )
	BRK (  )

( Parse the commands )
@monitor:parser:commands ( char -- )
	(      char       parser                   command                         )
	DUP LIT "q NEQ ?{ ;monitor:parser:commands .monitor:Command/quit    !/done }
	DUP LIT "% NEQ ?{ ;monitor:parser:commands .monitor:Command/debug   !/done }

	( On unknown command )
	[ LIT "? monitor:putc monitor:putc monitor:print-nl BRK ]

	&done
	( From the previous "table", store the new monitor state )
	;monitor:variables/cmd STA               ( Set the current command )
	;monitor:on-console/current-parser STA2  ( Set the current parser )
	POP   ( Drop the current char )
	BRK   ( Break out from vector handler )

@monitor:command:flush
	( Load the current the command )
	;monitor:variables/cmd LDA
	DUP .monitor:Command/quit      NEQ ?{ POP POP monitor:stop }
	DUP .monitor:Command/debug     NEQ ?{ DEBUG }

	( Drop the command loaded previously )
	POP

	( Sets back the parser to the commands parser )
	;monitor:parser:commands ;monitor:on-console/current-parser STA2
	( Sets back command to none )
	.monitor:Command/none ;monitor:variables/cmd STA
	JMP2r

( Prints short from stack )
@monitor:print-short ( short* -: )
	SWP
	monitor:byte2hex monitor:putc monitor:putc
( Prints byte from stack )
@monitor:print-byte  ( byte -: )
	monitor:byte2hex monitor:putc monitor:putc
	JMP2r

( Prints a newline )
@monitor:print-nl
	LIT 0a monitor:putc
	JMP2r

( Converts a given byte to the nibble chars, big-end on top. )
( [ big-end on top to allow directly sending stack to .Console/write ] )
@monitor:byte2hex ( value -: charLO charHI )
	DUP           ( Keep a copy of the value )
	monitor:nibble2hex    ( Convert low to char )
	SWP           ( Save result / restoring copied value )
	monitor:nibble:high   ( Keep the high nibble )
	monitor:nibble2hex    ( Convert high to char )
	JMP2r

( Converts the low nibble to its char )
@monitor:nibble2hex ( nibble -: char )
	monitor:nibble:low        ( Clamp to [0-f] range )
	[ DUP #09 GTH ]   ( should we output a letter? )
	[ #27 MUL ] ADD   ( add offset between ASCII letters and numbers as needed  )
	[ LIT "0  ] ADD   ( add offset of ASCII char '0' )
	JMP2r

( Converts the hex chars to the value )
@monitor:hex2value ( str* -: val* )
	[ LIT2r 0000 ]
	&w ( str* `acc* -: val* )
	LDAk monitor:hex2nibble INC #00 EQU ?{
		[ LITr 40 ] SFT2r LDAk monitor:hex2nibble [ LITr 00 ] STH
		ADD2r INC2 LDAk ?&w }
	POP2 STH2r
	JMP2r

( Converts the hex char [0-f] to the value )
@monitor:hex2nibble ( c -: val! )
	( dec ) [ LIT "0 ] SUB DUP #09 GTH ?{ JMP2r }
	( hex ) #27 SUB DUP #0f GTH ?{ JMP2r }
	( err ) POP #ff JMP2r

( Ouputs a string to the console )
@monitor:puts ( str* -: )
	LDAk console:putc
	INC2 LDAk ?puts
	POP2
	JMP2r

@monitor:_end

( Enums for the monitor )
|0000
@monitor:Command
	&none          $1
	&quit          $1
	( Monitoring commands )
	&debug         $1

( Reset the output address )
|monitor:_end
